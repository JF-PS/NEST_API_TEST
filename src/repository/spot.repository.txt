import { Injectable } from '@nestjs/common';
import { Prisma } from '@prisma/client';
import { SpotEntity } from 'src/entity/spot.entity';
import { PrismaService } from 'src/service/prisma.service';
import { plainToClass, plainToClassMany } from 'src/utils/plain-to-class';

export type spotPaginationInput = {
  take: number;
  skip: number;
};

@Injectable()
export class SpotRepository {
  constructor(private prisma: PrismaService) {}

  async getById(
    id: string,
    profileId?: string | undefined,
  ): Promise<SpotEntity> {
    const spot = await this.prisma.spot.findUnique({
      where: {
        id,
      },
      include: {
        profile: true,
        spotPicture: true,
        tags: { include: { tag: true } },
        _count: {
          select: { ratings: true },
        },
        ratings: {
          where: {
            profileId,
          },
        },
        favorites: {
          where: {
            profileId,
          },
        },
      },
    });

    return plainToClass(spot, SpotEntity);
  }

  async getAll(
    filterData: Prisma.SpotWhereInput,
    paginationData: Pick<Prisma.SpotFindManyArgs, 'take' | 'skip'>,
    orderBy: Prisma.SortOrder,
    searchValue: string,
    tagListId: string[],
    profileId?: string | undefined,
  ): Promise<SpotEntity[]> {
    const spotList = await this.prisma.spot.findMany({
      orderBy: {
        averageRating: orderBy,
      },

      where: {
        ...filterData,
        name: {
          contains: searchValue,
        },
        ...(tagListId && tagListId.length
          ? {
              tags: {
                some: {
                  OR: tagListId.map((tagId) => {
                    return {
                      tag: {
                        id: tagId,
                      },
                    };
                  }),
                },
              },
            }
          : {}),
      },

      ...paginationData,

      include: {
        spotPicture: true,
        tags: {
          include: {
            tag: true,
          },
        },
        favorites: {
          where: {
            profileId,
          },
        },
      },
    });

    return plainToClassMany(spotList, SpotEntity);
  }

  async updateAverageRatingBySpotId(
    spotId: string,
    avg: number,
  ): Promise<SpotEntity> {
    const spot = await this.prisma.spot.update({
      where: {
        id: spotId,
      },
      data: {
        averageRating: avg,
      },
    });
    return plainToClass(spot, SpotEntity);
  }

  async create(
    data: Omit<Prisma.SpotCreateInput, 'profile'>,
    pictures: { url: string }[],
    tags: { id: string }[],
    profileId: string,
  ): Promise<SpotEntity> {
    const spot = await this.prisma.spot.create({
      data: {
        ...data,
        tags: {
          create: tags.map((tag) => {
            return {
              tag: {
                connect: { id: tag.id },
              },
            };
          }),
        },
        profile: {
          connect: { id: profileId },
        },
        spotPicture: {
          create: [...pictures],
        },
      },
      include: { spotPicture: true, tags: { include: { tag: true } } },
    });

    return plainToClass(spot, SpotEntity);
  }

  // async update(
  //   data: SpotDto,
  //   spotId: string,
  //   tags: { id: string }[],
  //   pictures: UpdateSpotPicturesDto = [],
  // ): Promise<SpotEntity> {
  //   const spot = await this.prisma.spot.update({
  //     where: {
  //       id: spotId,
  //     },

  //     data: {
  //       ...data,
  //       tags: {
  //         deleteMany: {},
  //         create: tags?.map((tag) => {
  //           return {
  //             tag: {
  //               connect: { id: tag.id },
  //             },
  //           };
  //         }),
  //       },

  //       spotPicture: {
  //         deleteMany: {},
  //         create: [...pictures],
  //       },
  //     },

  //     include: { spotPicture: true, tags: { include: { tag: true } } },
  //   });
  //   return plainToClass(spot, SpotEntity);
  // }

  async delete(profileId: string, spotId: string): Promise<boolean> {
    return this.prisma.profile
      .update({
        where: {
          id: profileId,
        },
        data: {
          spots: {
            delete: {
              id: spotId,
            },
          },
        },
      })
      .then(() => true)
      .catch(() => false);
  }

  async getTagBySpotId(id: string) {
    const spotFind = this.prisma.spot.findUnique({
      where: {
        id,
      },
      include: { spotPicture: true, ratings: true, favorites: true },
    });
    return spotFind.tags;
  }
}
